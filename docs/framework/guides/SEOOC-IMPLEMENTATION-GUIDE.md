# SEooC 實施指南 - 從需求到 HSR/SSR 分配

**版本**: 1.0.0  
**日期**: 2025-12-02  
**語言**: 繁體中文 (zh-TW)

---

## 目錄

1. [SEooC 概念](#seooc-概念)
2. [工作流程](#工作流程)
3. [TSR 推導步驟](#tsr-推導步驟)
4. [HSR/SSR 分配流程](#hsrssr-分配流程)
5. [實例演練](#實例演練)
6. [常見問題](#常見問題)
7. [檢查清單](#檢查清單)

---

## SEooC 概念

### 什麼是 SEooC？

**SEooC** = Safety Element out of Context（離脈絡安全元件）

SEooC 是 ISO 26262 中的一個重要概念，用來表示：
- 一個安全元件（硬體、軟體、或其組合）
- 它被開發出來用於**特定的應用情景**
- 但在設計時，考慮的是**脫離具體應用脈絡**的通用情景
- 稍後在實際應用中被**應用到特定的系統**

### SEooC 的生命週期

```
┌─────────────────────────────────────────────────────────────┐
│ 階段 0：定義需求（本檔案涵蓋）                               │
│ ├─ 安全目標 (SG)                                              │
│ ├─ 功能安全需求 (FSR)                                        │
│ └─ 系統安全需求 (SysReq)                                     │
│                                                              │
│ ↓                                                             │
│                                                              │
│ 階段 1：推導 TSR（本檔案涵蓋）                                │
│ ├─ 推導技術安全需求 (TSR)                                    │
│ ├─ 故障分析 (FMEA/FTA)                                       │
│ └─ 診斷覆蓋率分析 (DC)                                        │
│                                                              │
│ ↓                                                             │
│                                                              │
│ 階段 2：分配 TSR（本檔案涵蓋）                                │
│ ├─ 分配 TSR 到硬體 (HSR)                                      │
│ ├─ 分配 TSR 到軟體 (SSR)                                      │
│ ├─ 定義硬體/軟體介面                                          │
│ └─ 驗證追蹤完整性                                             │
│                                                              │
│ ↓                                                             │
│                                                              │
│ 階段 3：詳細設計（由硬體/軟體團隊負責）                        │
│ ├─ 硬體詳細設計規格 (HDD)                                     │
│ └─ 軟體詳細設計規格 (SDD)                                     │
│                                                              │
│ ↓                                                             │
│                                                              │
│ 階段 4：實現與驗證（由硬體/軟體團隊負責）                      │
│ ├─ 硬體實現與單元測試                                        │
│ ├─ 軟體實現與單元測試                                        │
│ ├─ 整合測試                                                  │
│ └─ 系統驗證測試                                              │
│                                                              │
│ ↓                                                             │
│                                                              │
│ 階段 5：上線與維護                                            │
│ ├─ 產品發布                                                  │
│ └─ 故障追蹤與改進                                            │
└─────────────────────────────────────────────────────────────┘
```

本指南聚焦於**階段 1 和 2**（推導 TSR 和分配 TSR）。

---

## 工作流程

### 高層流程圖

```
開始
  ↓
[1] 蒐集功能安全需求 (FSR)
  ↓
[2] 進行故障分析 (FMEA/FTA)
  ↓
[3] 推導技術安全需求 (TSR)
  ├─ 每個 TSR 必須可追蹤回 FSR
  ├─ 每個 TSR 必須定義驗證方法
  └─ 每個 TSR 必須指定 ASIL 等級
  ↓
[4] 分配 TSR 到硬體 (HSR)
  ├─ 評估硬體可行性
  ├─ 定義硬體故障檢測機制
  └─ 定義硬體安全狀態
  ↓
[5] 分配 TSR 到軟體 (SSR)
  ├─ 評估軟體可行性
  ├─ 定義軟體故障處理邏輯
  └─ 定義軟體恢復機制
  ↓
[6] 設計硬體/軟體介面
  ├─ 定義信號和資料格式
  ├─ 定義時序要求
  └─ 定義故障通知協議
  ↓
[7] 構建追蹤矩陣
  ├─ SG → FSR → TSR → HSR/SSR
  └─ 驗證無缺口（gap-free）
  ↓
[8] 審查與核准
  ├─ 設計審查
  ├─ 安全審查
  └─ 管理簽核
  ↓
結束（進入詳細設計階段）
```

---

## TSR 推導步驟

### 步驟 1：蒐集和理解功能安全需求 (FSR)

**目標**: 清楚地列出所有相關的 FSR

**做法**:
1. 從安全目標 (SG) 和系統需求出發
2. 列出每個 FSR 的：
   - 需求 ID（如 FSR-001）
   - 需求文本（描述"做什麼"而非"怎麼做"）
   - ASIL 等級
   - 來源（哪個 SG）
3. 記錄前提條件和假設

**例**:
```
FSR-001: 當輸入電壓低於 [X] V 時，系統必須在 [T] ms 內進入安全狀態
- ASIL 等級: ASIL-D
- 來源: SG-001 (確保不因電源故障導致資料遺失)
- 前提: 系統運作溫度 0-85°C
```

### 步驟 2：進行故障分析 (FMEA/FTA)

**目標**: 識別所有相關故障模式，評估其風險

**做法**:

#### FMEA（故障模式與影響分析）
```
| 故障模式 | 可能原因 | 影響 | 檢測方法 | RPN | 緩解措施 |
|---------|---------|------|---------|-----|---------|
| VDD 跌落 | 電源故障 | 資料遺失 | 電壓監控 | 高 | TSR-001 |
| 時鐘丟失 | 振蕩器失效 | 系統停止 | 時鐘監控 | 高 | TSR-002 |
| 記憶體故障 | 位翻轉 | 資料損壞 | ECC/奇偶校驗 | 高 | TSR-003 |
```

#### FTA（故障樹分析）
```
              [頂事件：資料遺失]
                      |
            ┌─────────┼─────────┐
            |         |         |
        [VDD低]   [時鐘停]  [記憶體壞]
        /    \     /    \     /    \
    [缺陷]  [故障][停止][漂移][位反][ECC失效]
```

### 步驟 3：推導技術安全需求 (TSR)

**目標**: 將 FSR 轉化為可實現和可驗證的技術要求

**做法**:

1. **針對每個 FSR，提出"如何達到"的技術方案**
   ```
   FSR-001: 當輸入電壓低於 [X] V 時，系統必須在 [T] ms 內進入安全狀態
   
   推導為三個 TSR:
   - TSR-001: 硬體必須監控 VDD 並當 VDD < [X] V 時產生故障信號
   - TSR-002: 軟體必須在 [T1] ms 內檢測到故障信號
   - TSR-003: 軟體必須在 [T2] ms 內進入安全狀態
   - 其中 T1 + T2 < [T]
   ```

2. **定義可驗證的標準**
   ```
   TSR-001:
   - 驗證方法: 測試
   - 測試用例: 
     a) 將 VDD 從 [Y] V 逐步降低至 [X-0.1] V，確認無故障信號
     b) 將 VDD 降至 [X-0.05] V，確認產生故障信號
   - 通過標準: 在 (c) 產生故障信號，在 (b) 無故障信號
   ```

3. **指定 ASIL 等級**
   ```
   TSR-001: 繼承 FSR-001 的 ASIL-D
   TSR-002: 繼承 FSR-001 的 ASIL-D
   TSR-003: 繼承 FSR-001 的 ASIL-D
   （除非有特別論證需要升級或降級）
   ```

### TSR 推導檢查清單

- [ ] 每個 TSR 都可追蹤回一個 FSR
- [ ] 每個 TSR 都明確定義了驗證方法
- [ ] 每個 TSR 都指定了 ASIL 等級
- [ ] 每個 TSR 都定義了"是什麼"而非"怎麼做"
- [ ] 所有 TSR 的組合能完全滿足相應的 FSR
- [ ] 無孤立的 TSR（都有 FSR 支持）
- [ ] 無孤立的 FSR（都有對應的 TSR）

---

## HSR/SSR 分配流程

### 步驟 4：分配 TSR 到硬體 (HSR)

**目標**: 決定哪些 TSR 由硬體實現，並生成對應的 HSR

**做法**:

1. **評估硬體可行性**
   ```
   對於每個 TSR，問：
   - 這個 TSR 是否涉及實時性要求？
     ✓ 是 → 考慮硬體實現
   - 這個 TSR 是否涉及故障檢測？
     ✓ 是 → 通常硬體實現更可靠
   - 這個 TSR 是否涉及故障安全狀態？
     ✓ 是 → 優先硬體實現
   - 是否有成本約束？
     ✓ 是 → 評估軟體替代方案
   ```

2. **為每個硬體 TSR 生成 HSR**
   ```
   TSR-001: 硬體必須監控 VDD 並當 VDD < [X] V 時產生故障信號
   
   分配決策: 硬體實現（因為需要實時檢測，不能由軟體中斷延遲）
   
   HSR-001: 監控電路必須在 VDD 跌落至 [X-0.05] V 時產生 FAULT 信號 (高脈衝 1μs)
   - ASIL: ASIL-D (繼承 TSR-001)
   - 實現模塊: 模擬前端 (AFE) 監控電路
   - 驗證方法: 單元測試（硬體仿真）
   - 故障安全狀態: FAULT 默認為低（無故障態）
   ```

3. **定義硬體故障檢測和安全狀態**
   ```
   HSR-001 的故障檢測機制:
   - 監控電路本身也可能故障（如監控電路完全失效）
   - 設計對策: 使用冗餘監控電路（dual monitoring）
   - 或使用看門狗 (watchdog) 從軟體定期確認監控電路活性
   ```

### 步驟 5：分配 TSR 到軟體 (SSR)

**目標**: 決定哪些 TSR 由軟體實現，並生成對應的 SSR

**做法**:

1. **評估軟體可行性**
   ```
   對於每個 TSR，問：
   - 這個 TSR 的反應時間是否軟體可以滿足？
   - 是否需要基於硬體信號的後續邏輯處理？
     ✓ 是 → 軟體實現
   - 是否涉及複雜的狀態機或決策邏輯？
     ✓ 是 → 軟體實現更靈活
   - 是否需要頻繁更新或配置？
     ✓ 是 → 軟體更靈活
   ```

2. **為每個軟體 TSR 生成 SSR**
   ```
   TSR-002: 軟體必須在 [T1] ms 內檢測到故障信號
   
   分配決策: 軟體實現（故障檢測後的邏輯處理）
   
   SSR-001: 軟體監控任務必須每 [T1/2] ms 檢查一次 FAULT 信號狀態
   - ASIL: ASIL-D (繼承 TSR-002)
   - 實現模塊: 系統監控服務 (SysMon)
   - 驗證方法: 單元測試 + 整合測試
   - 故障處理: 設置故障標誌，觸發故障處理狀態機
   
   ---
   
   TSR-003: 軟體必須在 [T2] ms 內進入安全狀態
   
   分配決策: 軟體實現（安全狀態轉遷邏輯）
   
   SSR-002: 故障處理狀態機必須在檢測到故障信號後 [T2] ms 內轉遷至 SAFE 狀態
   - ASIL: ASIL-D (繼承 TSR-003)
   - 實現模塊: 故障管理器 (FaultMgr)
   - 驗證方法: 單元測試 + 場景模擬測試
   - 安全狀態定義: 停止所有 I/O 操作，進入觀察模式
   ```

3. **考慮軟體故障本身**
   ```
   SSR-002 本身的故障模式:
   - 軟體中的狀態機邏輯可能故障（如狀態轉遷代碼 bug）
   - 軟體棧故障（如中斷被禁用）
   
   設計對策:
   - 軟體冗餘檢查: 多個獨立路徑確認狀態轉遷
   - 硬體看門狗: 若軟體未能在時限內到達安全狀態，硬體看門狗強制復位
   ```

### 步驟 6：設計硬體/軟體介面

**目標**: 定義清晰的硬體和軟體之間的契約

**做法**:

1. **定義信號介面**
   ```
   訊號名稱    方向        寬度   電氣特性        時序
   ───────────────────────────────────────────────────
   FAULT       HW → SW     1 bit  3.3V TTL       < 1μs
   RESET_REQ   SW → HW     1 bit  3.3V TTL       脈衝 100ms
   STATUS_CODE HW → SW     8 bits 3.3V SPI       同步時鐘
   ```

2. **定義故障通知協議**
   ```
   當硬體檢測到故障：
   1. 硬體將 FAULT 信號設置為高（拉高 1μs）
   2. 硬體將 STATUS_CODE 設置為故障碼（如 0xA1 = VDD 低電壓）
   3. 軟體中斷服務例程 (ISR) 被觸發
   4. ISR 檢查 STATUS_CODE 並設置故障標誌
   5. 主應用检測到故障標誌，進入故障處理
   ```

3. **定義恢復協議**
   ```
   當軟體決定復位硬體：
   1. 軟體發送 RESET_REQ 高脈衝（持續 100ms）
   2. 硬體檢測到脈衝，啟動復位序列
   3. 硬體清除故障狀態，初始化監控電路
   4. 硬體復位完成後，將 READY 信號拉高
   5. 軟體檢測到 READY，確認復位成功，恢復正常運作
   ```

4. **定義時序要求**
   ```
   故障檢測到軟體反應時間 (Fault Response Time):
   = HW 偵測延遲 (< 1μs) 
     + 信號傳播延遲 (< 1μs)
     + ISR 觸發和執行延遲 (< 10μs ASPICE 規定)
     + 應用處理延遲 (< T1/2 = 2ms)
     = 總計 < 2.01ms
   
   驗收標準: Fault Response Time < [T1] = 5ms ✓ 合格
   ```

---

## 實例演練

### 案例：SSD 控制器電源故障保護

#### 背景
PCIe Gen5 SSD 控制器在電源故障時必須保護快閃記憶體資料完整性。

#### 安全目標 (SG)
```
SG-001: 確保在電源故障時，快閃記憶體資料不會損壞
```

#### 功能安全需求 (FSR)
```
FSR-001: 當輸入電壓 VDD 低於 2.7V 時，系統必須在 10ms 內進入安全狀態
- ASIL: ASIL-D
- 前提: 系統運作電壓為 3.3V ±5%，即正常 3.135V - 3.465V
```

#### 故障分析 (FMEA)
```
| 故障模式 | 原因 | 影響 | 檢測方法 | 缺陷評級 |
|---------|------|------|--------|--------|
| VDD 快速跌落 | 電源中斷 | 快閃操作中斷，資料遺失 | VDD 監控 | 高 |
| VDD 緩慢下降 | 電源問題 | 邏輯運作不穩定 | VDD 監控 | 高 |
| 監控電路失效 | 硬體缺陷 | 無法偵測故障 | 冗餘監控 | 高 |
```

#### TSR 推導
```
根據 FSR-001，推導三個 TSR：

TSR-001: VDD 監控電路
- 需求: 當 VDD < 2.7V 時產生 FAULT 信號（高脈衝 1μs）
- ASIL: ASIL-D
- 驗證: 測試（軟體注入低電壓，確認信號產生）

TSR-002: 軟體故障檢測
- 需求: 軟體在 5ms 內讀取並確認 FAULT 信號
- ASIL: ASIL-D
- 驗證: 測試（注入 FAULT 信號，測量軟體反應時間）

TSR-003: 安全狀態轉遷
- 需求: 軟體在檢測到故障後 5ms 內進入安全狀態
- ASIL: ASIL-D
- 驗證: 測試（監控快閃控制訊號和記憶體寫入是否停止）
```

#### HSR/SSR 分配
```
TSR-001 → HSR-001: 監控電路實現故障檢測
- 實現: 模擬前端監控電路
- 故障安全: FAULT 默認低（無故障）
- 冗餘: 雙監控電路（獨立故障檢測）

TSR-002 → SSR-001: 軟體定期檢查 FAULT 信號
- 實現: SysMon 任務，週期 2.5ms
- 反應: 設置故障標誌，觸發 ISR

TSR-003 → SSR-002: 軟體狀態機進入安全狀態
- 實現: FaultMgr 停止快閃操作，禁止記憶體寫入
- 看門狗: 若 5ms 內未到達安全狀態，硬體看門狗強制復位
```

#### 介面定義
```
FAULT (HW → SW):
- 寬度: 1 bit
- 電氣: 3.3V TTL，高有效
- 時序: HW 在 1μs 內產生脈衝

STATUS_CODE (HW → SW):
- 寬度: 8 bits
- 格式: 0xA1 = VDD 低電壓故障
- 時序: 與 FAULT 同時更新

RESET_REQ (SW → HW):
- 寬度: 1 bit
- 脈衝寬度: 100ms
- 效果: HW 復位監控電路，清除故障狀態
```

---

## 常見問題

### Q1: TSR 和 FSR 的區別是什麼？

**A**: 
- **FSR (Functional Safety Requirement)**: 功能層面的安全需求，描述系統需要"做什麼"以確保安全
  ```
  例: "當電壓低於 2.7V 時，系統必須在 10ms 內進入安全狀態"
  ```

- **TSR (Technical Safety Requirement)**: 技術層面的安全需求，描述"如何技術實現"以滿足 FSR
  ```
  例: "VDD 監控電路必須在電壓低於 2.7V 時產生 FAULT 信號"
  ```

### Q2: 何時應該使用硬體實現，何時使用軟體？

**A**: 決策表：
```
因素           優先硬體                  優先軟體              雙重實現
───────────────────────────────────────────────────────
實時性(< 1ms)  ✓ 硬體更快               ✗ 軟體延遲高         ✓ 備用
故障檢測        ✓ 硬體可靠               ⚠ 軟體可能失效        ✓ 冗餘
故障安全狀態    ✓ 硬體默認安全           ⚠ 軟體可能失效        ✓ 最安全
靈活性          ✗ 硬體固定               ✓ 軟體可升級          折中
成本            ✗ 可能較高               ✓ 較低               ✗ 最高
```

### Q3: ASIL 是否會在 TSR 分配時改變？

**A**: 通常不會，但有例外：
- **正常情況**: TSR 繼承 FSR 的 ASIL 等級
- **例外 1 - 升級**: 若 TSR 涉及關鍵故障檢測，可能升級
  ```
  例: FSR-001 是 ASIL-C，但 TSR-001 的故障檢測電路本身是單點故障，升級為 ASIL-D
  ```
- **例外 2 - 降級**: 若有獨立故障假設（ISO 26262-3 Part 8），可能降級
  ```
  例: HSR-001 + SSR-001 雙重實現，硬體故障和軟體故障獨立，組合降級為 ASIL-B
  需要論證和審查
  ```

### Q4: 如何驗證 TSR 和 HSR/SSR 的完整性（gap-free）？

**A**: 建立追蹤矩陣檢查：
```
1. 正向追蹤: SG → FSR → TSR → HSR/SSR
   ✓ 每個 SG 都有對應的 FSR
   ✓ 每個 FSR 都有對應的 TSR
   ✓ 每個 TSR 都有對應的 HSR 或 SSR

2. 反向追蹤: HSR/SSR → TSR → FSR → SG
   ✓ 每個 HSR/SSR 都可追蹤回 TSR
   ✓ 每個 TSR 都可追蹤回 FSR
   ✓ 每個 FSR 都可追蹤回 SG

3. 缺口分析:
   ✗ 孤立的 HSR/SSR（無 TSR 支持）→ 需要添加或移除
   ✗ 孤立的 TSR（無 FSR 支持）→ 需要添加或移除
   ✗ 孤立的 FSR（無 TSR 實現）→ 需要添加 TSR
```

### Q5: 硬體和軟體之間的介面如何定義才能確保安全？

**A**: 介面定義檢查清單：
```
☐ 信號定義: 寬度、電氣特性、有效態
☐ 時序要求: 脈衝寬度、響應時間、同步方式
☐ 故障模式: 信號丟失、延遲、錯誤等
☐ 故障通知: HW 如何通知 SW 故障
☐ 恢復協議: SW 如何觸發 HW 恢復
☐ 診斷監控: 介面本身的健康檢查
☐ 文檔版本: 介面規范版本化和變更管理
```

---

## 檢查清單

### 需求蒐集檢查清單
- [ ] 所有安全目標 (SG) 已記錄
- [ ] 所有功能安全需求 (FSR) 已記錄
- [ ] 每個 FSR 都指定了 ASIL 等級
- [ ] 每個 FSR 都明確定義了功能和時序要求
- [ ] 所有前提條件和邊界條件已列出
- [ ] 沒有孤立的需求（都有來源）

### 故障分析檢查清單
- [ ] 完成了 FMEA（故障模式與影響分析）
- [ ] 完成了 FTA（故障樹分析）
- [ ] 所有高風險故障模式都有緩解措施
- [ ] 診斷覆蓋率評估已完成（目標 > 90%）
- [ ] 故障排除覆蓋率已評估

### TSR 推導檢查清單
- [ ] 每個 FSR 都對應了一個或多個 TSR
- [ ] 每個 TSR 都可追蹤回一個 FSR
- [ ] 每個 TSR 都明確定義了驗證方法和標準
- [ ] 每個 TSR 都指定了 ASIL 等級
- [ ] 所有 TSR 都定義了"是什麼"而非"怎麼做"
- [ ] 所有 TSR 的組合能完全滿足對應的 FSR

### HSR/SSR 分配檢查清單
- [ ] 每個 TSR 都分配到了 HSR、SSR 或兩者
- [ ] 每個 HSR 都對應一個 TSR
- [ ] 每個 SSR 都對應一個 TSR
- [ ] 分配決策都有文檔化的理由
- [ ] ASIL 等級在分配中保持或有論證
- [ ] 沒有孤立的 HSR/SSR（都有 TSR 支持）

### 介面定義檢查清單
- [ ] 所有 HW ↔ SW 信號都已定義
- [ ] 所有信號的電氣特性都已指定
- [ ] 所有信號的時序要求都已定義
- [ ] 故障通知協議已明確
- [ ] 恢復協議已明確
- [ ] 介面時序圖已繪製
- [ ] 介面異常情況已考慮

### 追蹤與覆蓋率檢查清單
- [ ] 追蹤矩陣已建立 (SG → FSR → TSR → HSR/SSR)
- [ ] 追蹤矩陣已驗證無缺口 (gap-free)
- [ ] 所有 SG 都有 FSR 支持
- [ ] 所有 FSR 都有 TSR 實現
- [ ] 所有 TSR 都有 HSR/SSR 分配
- [ ] 覆蓋率達到 100%（或有文檔化的豁免）

### 審查與核准檢查清單
- [ ] 技術審查已完成
- [ ] 安全審查已完成
- [ ] 所有審查意見已處理
- [ ] 文檔已簽核（作者、設計主管、安全主管、項目經理）
- [ ] 所有變更都已版本化
- [ ] 文檔已納入配置管理

---

**End of SEooC Implementation Guide**
